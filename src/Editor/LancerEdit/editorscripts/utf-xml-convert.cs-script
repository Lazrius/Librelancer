// [Script]
// name = Convert UTF to/from XML

using System;
using System.Numerics;
using System.Xml;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Xml.Serialization;
using LibreLancer;
using LibreLancer.Utf;
using LibreLancer.Utf.Ale;
using LibreLancer.Utf.Anm;
using LibreLancer.Utf.Audio;
using LibreLancer.Utf.Mat;
using LibreLancer.ContentEdit;
using WattleScript.Interpreter;
using ExtendedXmlSerializer;
using ExtendedXmlSerializer.Configuration;
using ExtendedXmlSerializer.ContentModel;
using ExtendedXmlSerializer.ContentModel.Content;
using ExtendedXmlSerializer.ContentModel.Format;
using ExtendedXmlSerializer.Core;
using ExtendedXmlSerializer.ExtensionModel;

ScriptUsage(@"-src='input file / input directory' -dest='output file / output directory'
Output will be .xml if the input is .ale|.cmp|.3db, else it will be determined by the xml file.");

string input = "";
string output = "";
int threadCount = 1;
StringOption("src=", "Source File / Directory", x => input = x);
StringOption("dest=", "Source File / Directory", x => output = x);
IntegerOption("threads=", "Thread Count (default 1)", v => threadCount = v);

void XmlToUtf(string file)
{

}

void UtfToXml(string file)
{
    var utf = Autodetect.Load(file);
    string contents = null;

    if (utf.Ale is not null)
    {
        contents = Serializer<AleFile>.Serialize(utf.Ale);
    }
    else if (utf.Voice is not null)
    {
        UtfVoice voice = new();
        voice.Lines = utf.Voice.AudioFiles.Select(x => new UtfVoice.VoiceLine { Id = x.Key, Data = x.Value }).ToArray();

        contents = Serializer<UtfVoice>.Serialize(voice);
    }
    else if (utf.Textures is not null)
    {
        contents = Serializer<TxmFile>.Serialize(utf.Textures);
    }
    else if (utf.Materials is not null)
    {
        contents = Serializer<MatFile>.Serialize(utf.Materials);
    }
    else if (utf.StandardAnm is not null)
    {
        contents = Serializer<AnmFile>.Serialize(utf.StandardAnm);
    }

    if (contents is null)
    {
        Console.WriteLine($"Unable to detect type of file: {file}");
        return;
    }

    File.WriteAllText(output, contents);
}

// Script Start

_ = ParseArguments();

if (input is "" || output is "" || threadCount <= 0)
{
    Console.WriteLine(@"Invalid options provided.
    src and dest must be valid file/folder paths.
    threads must be greater or equal to 1.");
    return;
}

bool isFile = false;
if (!File.Exists(input))
{
    if (!Directory.Exists(input))
    {
        Console.WriteLine("Input was not an existing file or directory.");
        return;
    }
}
else
{
    isFile = true;
}

if (isFile)
{
    if (input.EndsWith(".xml"))
    {
        XmlToUtf(input);
        return;
    }

    UtfToXml(input);
    return;
}

enum UtfType
{
    Ale,
    Audio,
    VisualResource,
}

public class Autodetect : UtfFile
{
    public AleFile Ale;
    public AnmFile StandardAnm;
    public IDrawable Drawable;
    public TxmFile Textures;
    public MatFile Materials;
    public VoiceUtf Voice;

    public static Autodetect Load(string file)
    {
        IntermediateNode root;
        using (var stream = File.OpenRead(file))
        {
            root = parseFile(file, stream);
        }

        bool hasAnm = false;
        bool hasAle = false;
        bool isModel = false;
        bool maybeAudio = false;
        IntermediateNode textureLibrary = null;
        IntermediateNode materialLibrary = null;
        foreach (var n in root)
        {
            if (n.Name.StartsWith("0x", StringComparison.OrdinalIgnoreCase))
                maybeAudio = true;
            switch (n.Name.ToLowerInvariant())
            {
                case "aleffectlib":
                case "alchemynodelibrary":
                    hasAle = true;
                    break;
                case "sphere":
                case "vmeshpart":
                case "cmpnd":
                case "multilevel":
                case "hardpoints":
                case "skeleton":
                    isModel = true;
                    break;
                case "script":
                    hasAnm = true;
                    break;
                case "texture library":
                    textureLibrary = (IntermediateNode)n;
                    break;
                case "material library":
                    materialLibrary = (IntermediateNode)n;
                    break;
            }
            if (hasAle || isModel)
                break;
        }

        var ad = new Autodetect();
        if (hasAle)
        {
            using var stream = File.OpenRead(file);
            ad.Ale = new AleFile(file, stream);
        }
        else if (isModel)
        {
            ad.Drawable = UtfLoader.GetDrawable(root, null, file);
        }
        else if (textureLibrary != null || materialLibrary != null)
        {
            if (textureLibrary != null)
                ad.Textures = new TxmFile(textureLibrary);
            if(materialLibrary != null)
                ad.Materials = new MatFile(materialLibrary);
        }
        else if (hasAnm)
        {
            using var stream = File.OpenRead(file);
            ad.StandardAnm = new AnmFile(file, stream);
        }
        else if (maybeAudio)
        {
            using var stream = File.OpenRead(file);
            ad.Voice = new VoiceUtf(file, stream);
        }

        return ad;
    }
}

public sealed class Extension : ISerializerExtension
{
    public static Extension Default { get; } = new Extension();

    public Extension() {}
    public IServiceRepository Get(IServiceRepository parameter) => parameter.DecorateContentsWith<Contents>().Then();
    void ICommand<IServices>.Execute(IServices parameter) {}

    public sealed class Contents : IContents
    {
        readonly IContents        _previous;
        readonly ISerializer<ArraySegment<byte>?> _arraySegmentSerializer;

        public Contents(IContents previous)
            : this(previous, new ArraySegmentByteSerializer(previous.Get(typeof(ArraySegment<byte>?)).For<ArraySegment<byte>?>())) {}

        public Contents(IContents previous, ISerializer<ArraySegment<byte>?> arraySegmentSerializer)
        {
            _previous = previous;
            _arraySegmentSerializer = arraySegmentSerializer;
        }

        public ISerializer Get(TypeInfo parameter)
            => parameter == typeof(ArraySegment<byte>?) ? _arraySegmentSerializer.Adapt() : _previous.Get(parameter);
    }

    public sealed class ArraySegmentByteSerializer : ISerializer<ArraySegment<byte>?>
    {
        public ArraySegmentByteSerializer(ISerializer<ArraySegment<byte>?> _) {}

        public ArraySegment<byte>? Get(IFormatReader parameter)
        {
            var data = parameter.Content();
            Span<byte> buffer = new Span<byte>(new byte[data.Length]);
            Convert.TryFromBase64String(data, buffer, out int bytesParsed);
            if (bytesParsed != buffer.Length)
            {
                throw new ArgumentException(nameof(data), "Invalid Base64 String");
            }

            return new ArraySegment<byte>?(buffer.ToArray());
        }

        public void Write(IFormatWriter writer, ArraySegment<byte>? instance)
        {
            writer.Content(Convert.ToBase64String(instance.Value.Array));
        }
    }
}

public class Serializer<T> where T : class
{
    public static string Serialize(T obj)
    {
        IExtendedXmlSerializer serializer = new ConfigurationContainer()
            .UseAutoFormatting()
            .EnableImplicitTyping(typeof(T))
            .Extend(Extension.Default)
            .Create();

        return serializer.Serialize(new XmlWriterSettings()
        {
            Indent = true,
        }, obj);
    }
}
